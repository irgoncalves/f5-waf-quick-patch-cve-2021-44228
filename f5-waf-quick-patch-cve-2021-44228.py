# F5 WAF - quick patch for CVE-2021-44228
# This script creates a custom signature set with the relevant signatures for the CVE, apply to all policies in blocking mode and enforce the signatures as well apply 
# the changes to the policies
# TODO: implement general error handling 
# WARNING: this might increase control plane CPU and memory usage
# Ismael Goncalves
import argparse
import csv
import datetime
import getpass
import json
import os
import requests
import urllib3

# signatures ID relevant to the CVE
# CVE-2021-4228
# https://support.f5.com/csp/article/K19026212

sigs = ['200104768', '200104769', '200004450', '200004451','200004474','200104770','200104771','200104772','200104773']
sig_set = 'CVE-2021-44228'

def get_token(b, url_base, creds):
    url_auth = '%s/shared/authn/login' % url_base
    try:
        payload = {}
        payload['username'] = creds[0]
        payload['password'] = creds[1]
        payload['loginProviderName'] = 'tmos'
        token = b.post(url_auth, json.dumps(payload)).json()['token']['token']
    except:
        token = '' 
    return token

def audit_asm_policies_high_level(device):

    print('Working on ASM policies for device %s - only policies in BLOCKING mode' % device)
 
    # filter policies - obtains policy ID, name, enforcement mode
    url_base_asm = 'https://%s/mgmt/tm/asm/policies/?$select=id,name,enforcementMode,type' % device
    
    r = bigip.get(url_base_asm)
    json_data = r.json()

    for i in json_data['items']:
        if( i['type']=='parent'):
            continue
        # operation for policies in blocking mode only 
        if(i['enforcementMode']=='blocking'):
            print('Enforcing selected signatures on device %s policy %s' % (device,i['name']))
            apply_signature_set(i['id'])
            
def apply_signature_set(policy_id):
    
    url_apply_pol = 'https://%s/mgmt/tm/asm/tasks/apply-policy' % (device)
    payload_apply = '{"policyReference":{"link":"https://localhost/mgmt/tm/asm/policies/%s"}}' % (policy_id)
    payload_enfor = '{"performStaging":false}'
    url_policy = 'https://%s/mgmt/tm/asm/policies/%s/signature-sets' % (device,policy_id)
    
    # assign new signature set to policies in blocking mode
    payload_sig_set = '{"signatureSetReference":{"link":"https://localhost/mgmt/tm/asm/signature-sets/%s"}}' % (sig_set_id)
    print(payload_sig_set)
    r = bigip.post(url_policy,payload_sig_set)
    print(r.text)

    # enforce each new signature
    for s in sigs:
        url_cve_sigs  = 'https://%s/mgmt/tm/asm/policies/%s/signatures?$expand=signatureReference&$filter=inPolicy+eq+true+and+signature/signatureId+eq+\'%s\'' % (device,policy_id,s)
        r = bigip.patch(url_cve_sigs,payload_enfor)
        print("Status code for enforcement: " + str(r.status_code))
    
    # apply changes to the policy     
    r = bigip.post(url_apply_pol, payload_apply)
    print("Status code for apply changes: " + str(r.status_code))

def create_signature_set(device):

    # obtain signature hash (id) info about the relevant signatures for the CVE
    sig_ids = []
    for s in sigs:
        url_sig = 'https://%s/mgmt/tm/asm/signatures?$filter=signatureId+eq+%s' % (device,s)
        r = bigip.get(url_sig)
        json_data = r.json()
        for i in json_data['items']:
            sig_ids.append(i['id'])
        # notice script user about missing attack signatures
        if len(json_data['items']) == 0:
            print('Please note, attack signature %s is not exists in your device %s.\r\nPlease make sure you have the latest attack signatures package.' % (s,device))
    
    print(sig_ids)
    
    # create custom set with a single signature - TODO: a JSON object can be created and an array of signatures added 
    # however this was not done this time :(
    url_sig_set = 'https://%s/mgmt/tm/asm/signature-sets' % device
    in_payload = ""
    # build signatures references 
    for s in sig_ids:
        in_payload = in_payload + '{"link":"https://localhost/mgmt/tm/asm/signatures/%s"},' % s
    in_payload = in_payload.rstrip(",")

    payload_sig_set = '{"name":"%s","category":"User-defined","type":"manual","signatureReferences":[%s]}' % (sig_set,in_payload)

    r = bigip.post(url_sig_set, payload_sig_set)
    sig_set_id = r.json()

    return sig_set_id['id']

def check_active(device):
    
    # obtain device name
    url_base_asm = 'https://%s/mgmt/tm/sys/global-settings?$select=hostname' % device
    
    r = bigip.get(url_base_asm)
    hostname = r.json()['hostname']
 
    url_base_asm = 'https://%s/mgmt/tm/cm/traffic-group/traffic-group-1/stats?$select=deviceName,failoverState' % device
    r = bigip.get(url_base_asm)
    json_data = r.json()
    
    for i in json_data['entries']:
        devices = json_data['entries'][i]['nestedStats']
        # returns similar to 
        #{'entries': {'deviceName': {'description': '/Common/bigip1.f5labs.net'}, 'failoverState': {'description': 'standby'}}}
        device = devices['entries']['deviceName']['description']
        state = devices['entries']['failoverState']['description']
        
        if (hostname in device) and ('active' in state):
            return True
         
    return False

if __name__ == "__main__":
    urllib3.disable_warnings()

    parser = argparse.ArgumentParser()

    parser.add_argument("device", help='BIG-IP devices list separated by line')
    args = vars(parser.parse_args())

    device = args['device']

    username = input('Enter your username: ') 
    password = getpass.getpass('Enter your password')

    with open(device,'r') as a_file:
        for line in a_file:
            device = line.strip()
            # TODO - test connectivity with each device and report on the ones failing 
            url_base = 'https://%s/mgmt' % device
            bigip = requests.session()
            bigip.headers.update({'Content-Type': 'application/json'})
            bigip.auth = (username, password)
            bigip.verify = False
            token = get_token(bigip, url_base, (username, password))
            if (not token):
                print('Unable to obtain token for device ' + device)
                continue 
            bigip.headers.update({'X-F5-Auth-Token': token})
            bigip.auth = None
            if not check_active(device): 
                print('Device ' + device + ' is not active, skipping it...')
                continue
            sig_set_id = create_signature_set(device)
            audit_asm_policies_high_level(device)
 
